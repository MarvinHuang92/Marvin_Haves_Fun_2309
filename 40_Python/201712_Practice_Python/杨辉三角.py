# -*- coding: utf-8 -*-

def triangles():
	L = [1,0,0,0,0,0,0,0,0,0] # 初始化L，M列表，之所以用两个，因为后面逐一计算加法的时候需要M暂时“另存为”，不改变原来的L
	M = [1,0,0,0,0,0,0,0,0,0]
	T = [1] # 先生成第一行
	yield T
	for a in range (2,11): # 截断L，a=2时截断到序号1，也就是包含L[0],L[1]两个元素
		for b in range (1,10): # 逐一累加
			M[b] = L[b-1] + L[b]
		for c in range (0,10): # 此处不能直接令L=M，而是要里面的元素对应相等，不知道为什么
			L[c] = M[c]
		T = L[:a]
		yield T

# 这是一个很笨的方法，缺点是：已经规定了只能写10行，不能无限扩展
# 考虑到函数本身有一个参数位置是空缺的，可以利用它来优化


# 期待输出:
# [1]
# [1, 1]
# [1, 2, 1]
# [1, 3, 3, 1]
# [1, 4, 6, 4, 1]
# [1, 5, 10, 10, 5, 1]
# [1, 6, 15, 20, 15, 6, 1]
# [1, 7, 21, 35, 35, 21, 7, 1]
# [1, 8, 28, 56, 70, 56, 28, 8, 1]
# [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]
n = 0
results = []
for t in triangles():
    print(t)
    results.append(t)
    n = n + 1
    if n == 10:
        break
if results == [
    [1],
    [1, 1],
    [1, 2, 1],
    [1, 3, 3, 1],
    [1, 4, 6, 4, 1],
    [1, 5, 10, 10, 5, 1],
    [1, 6, 15, 20, 15, 6, 1],
    [1, 7, 21, 35, 35, 21, 7, 1],
    [1, 8, 28, 56, 70, 56, 28, 8, 1],
    [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]
]:
    print('测试通过!')
else:
    print('测试失败!')